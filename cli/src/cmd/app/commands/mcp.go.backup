package commands

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/spf13/cobra"
)

// NewMCPCommand creates the mcp command with subcommands.
func NewMCPCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:    "mcp",
		Short:  "Model Context Protocol server operations",
		Long:   `Manage the Model Context Protocol (MCP) server for AI assistant integration`,
		Hidden: true, // Hidden from help - primarily used by azd internally
	}

	cmd.AddCommand(newMCPServeCommand())

	return cmd
}

// newMCPServeCommand creates the mcp serve subcommand.
func newMCPServeCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "serve",
		Short: "Start the MCP server",
		Long:  `Starts the Model Context Protocol server to expose azd app functionality to AI assistants`,
		RunE:  runMCPServe,
	}
}

// runMCPServe starts the MCP server using Go implementation.
func runMCPServe(cmd *cobra.Command, args []string) error {
	return runMCPServer(cmd.Context())
}

// runMCPServer implements the MCP server logic
func runMCPServer(ctx context.Context) error {
	// System instructions to guide AI on how to use the tools
	instructions := `This MCP server provides tools to monitor and operate on azd app projects.

**Best Practices:**
1. Always use get_services to check current state before starting/stopping services
2. Use check_requirements before installing dependencies to see what's needed
3. Use get_service_logs to diagnose issues when services fail to start
4. Read azure.yaml resource to understand project structure before operations

**Tool Categories:**
- Observability: get_services, get_service_logs, get_project_info
- Operations: run_services, stop_services, restart_service, install_dependencies
- Configuration: check_requirements, get_environment_variables, set_environment_variable`

	// Create MCP server with all capabilities
	s := server.NewMCPServer(
		"azd-app-mcp-server", "0.1.0",
		server.WithToolCapabilities(true),
		server.WithResourceCapabilities(false, true), // subscribe=false, listChanged=true
		server.WithPromptCapabilities(false),          // listChanged=false
		server.WithInstructions(instructions),
	)

	// Add tools
	tools := []server.ServerTool{
		// Observability tools
		newGetServicesTool(),
		newGetServiceLogsTool(),
		newGetProjectInfoTool(),
		// Operational tools
		newRunServicesTool(),
		newStopServicesTool(),
		newRestartServiceTool(),
		newInstallDependenciesTool(),
		newCheckRequirementsTool(),
		// Configuration tools
		newGetEnvironmentVariablesTool(),
		newSetEnvironmentVariableTool(),
	}

	s.AddTools(tools...)

	// Add resources
	resources := []server.ServerResource{
		newAzureYamlResource(),
		newServiceConfigResource(),
	}

	s.AddResources(resources...)

	// Start the server using stdio transport
	if err := server.ServeStdio(s); err != nil {
		fmt.Fprintf(os.Stderr, "MCP server error: %v\n", err)
		return err
	}

	return nil
}

// executeAzdAppCommand executes an azd app command and returns JSON output
func executeAzdAppCommand(command string, args []string) (map[string]interface{}, error) {
	cmdArgs := append([]string{command}, args...)
	cmdArgs = append(cmdArgs, "--output", "json")

	cmd := exec.Command("azd", append([]string{"app"}, cmdArgs...)...)
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to execute azd app %s: %w", command, err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(output, &result); err != nil {
		return nil, fmt.Errorf("failed to parse JSON output: %w", err)
	}

	return result, nil
}

// Helper functions for common MCP patterns

// getStringParam safely extracts a string parameter from request arguments
func getStringParam(args map[string]interface{}, key string) (string, bool) {
	if val, ok := args[key].(string); ok && val != "" {
		return val, true
	}
	return "", false
}

// getFloat64Param safely extracts a float64 parameter from request arguments
func getFloat64Param(args map[string]interface{}, key string) (float64, bool) {
	if val, ok := args[key].(float64); ok {
		return val, true
	}
	return 0, false
}

// marshalToolResult marshals data to JSON and returns an MCP tool result
func marshalToolResult(data interface{}) (*mcp.CallToolResult, error) {
	jsonBytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
	}
	return mcp.NewToolResultText(string(jsonBytes)), nil
}

// extractProjectDirArg extracts projectDir argument and returns command args
func extractProjectDirArg(args map[string]interface{}) []string {
	var cmdArgs []string
	if projectDir, ok := getStringParam(args, "projectDir"); ok {
		cmdArgs = append(cmdArgs, "--project", projectDir)
	}
	return cmdArgs
}

// validateRequiredParam validates that a required parameter exists
func validateRequiredParam(args map[string]interface{}, key string) error {
	if val, ok := args[key].(string); !ok || val == "" {
		return fmt.Errorf("%s parameter is required", key)
	}
	return nil
}

// newGetServicesTool creates the get_services tool
func newGetServicesTool() server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool(
			"get_services",
			mcp.WithDescription("Get comprehensive information about all running services in the current azd app project. Returns service status, health, URLs, ports, Azure deployment information, and environment variables."),
			mcp.WithReadOnlyHintAnnotation(true),
			mcp.WithIdempotentHintAnnotation(true),
			mcp.WithDestructiveHintAnnotation(false),
			mcp.WithString("projectDir",
				mcp.Description("Optional project directory path. If not provided, uses current directory."),
			),
		),
		Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			args, _ := request.Params.Arguments.(map[string]interface{})
			
			cmdArgs := extractProjectDirArg(args)

			result, err := executeAzdAppCommand("info", cmdArgs)
			if err != nil {
				return mcp.NewToolResultError(fmt.Sprintf("Failed to get services: %v", err)), nil
			}

			return marshalToolResult(result)
		},
	}
}

// newGetServiceLogsTool creates the get_service_logs tool
func newGetServiceLogsTool() server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool(
			"get_service_logs",
			mcp.WithDescription("Get logs from running services. Can filter by service name, log level, and time range. Supports both recent logs and live streaming."),
			mcp.WithReadOnlyHintAnnotation(true),
			mcp.WithIdempotentHintAnnotation(true),
			mcp.WithDestructiveHintAnnotation(false),
			mcp.WithString("serviceName",
				mcp.Description("Optional service name to filter logs. If not provided, shows logs from all services."),
			),
			mcp.WithNumber("tail",
				mcp.Description("Number of recent log lines to retrieve. Default is 100."),
			),
			mcp.WithString("level",
				mcp.Description("Filter by log level: 'info', 'warn', 'error', 'debug', or 'all'. Default is 'all'."),
			),
			mcp.WithString("since",
				mcp.Description("Show logs since duration (e.g., '5m', '1h', '30s'). If provided, overrides tail parameter."),
			),
		),
		Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			args, _ := request.Params.Arguments.(map[string]interface{})

			var cmdArgs []string

			if serviceName, ok := getStringParam(args, "serviceName"); ok {
				cmdArgs = append(cmdArgs, serviceName)
			}

			if tail, ok := getFloat64Param(args, "tail"); ok && tail > 0 {
				cmdArgs = append(cmdArgs, "--tail", fmt.Sprintf("%.0f", tail))
			}

			if level, ok := getStringParam(args, "level"); ok && level != "all" {
				cmdArgs = append(cmdArgs, "--level", level)
			}

			if since, ok := getStringParam(args, "since"); ok {
				cmdArgs = append(cmdArgs, "--since", since)
			}

			// Add format flag for JSON output
			cmdArgs = append(cmdArgs, "--format", "json")

			// Execute logs command
			cmd := exec.Command("azd", append([]string{"app", "logs"}, cmdArgs...)...)
			output, err := cmd.Output()
			if err != nil {
				return mcp.NewToolResultError(fmt.Sprintf("Failed to get logs: %v", err)), nil
			}

			// Parse line-by-line JSON output
			logEntries := []map[string]interface{}{}
			lines := strings.Split(strings.TrimSpace(string(output)), "\n")
			for _, line := range lines {
				if line == "" {
					continue
				}
				var entry map[string]interface{}
				if err := json.Unmarshal([]byte(line), &entry); err == nil {
					logEntries = append(logEntries, entry)
				}
			}

			return marshalToolResult(logEntries)
		},
	}
}

// newGetProjectInfoTool creates the get_project_info tool
func newGetProjectInfoTool() server.ServerTool {
	return server.ServerTool{
		Tool: mcp.NewTool(
			"get_project_info",
			mcp.WithDescription("Get project metadata and configuration from azure.yaml. Returns project name, directory, and service definitions."),
			mcp.WithReadOnlyHintAnnotation(true),
			mcp.WithIdempotentHintAnnotation(true),
			mcp.WithDestructiveHintAnnotation(false),
			mcp.WithString("projectDir",
				mcp.Description("Optional project directory path. If not provided, uses current directory."),
			),
		),
		Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			args, _ := request.Params.Arguments.(map[string]interface{})

			cmdArgs := extractProjectDirArg(args)

			result, err := executeAzdAppCommand("info", cmdArgs)
			if err != nil {
				return mcp.NewToolResultError(fmt.Sprintf("Failed to get project info: %v", err)), nil
			}

			// Extract just project-level info
			projectInfo := map[string]interface{}{
				"project": result["project"],
			}

			// Extract service metadata (name, language, framework, project path)
			if services, ok := result["services"].([]interface{}); ok {
				simplifiedServices := []map[string]interface{}{}
				for _, svc := range services {
					if svcMap, ok := svc.(map[string]interface{}); ok {
						simplified := map[string]interface{}{
							"name":      svcMap["name"],
							"language":  svcMap["language"],
							"framework": svcMap["framework"],
							"project":   svcMap["project"],
						}
						simplifiedServices = append(simplifiedServices, simplified)
					}
				}
				projectInfo["services"] = simplifiedServices
			}

			return marshalToolResult(projectInfo)
		},

			return mcp.NewToolResultText(string(jsonBytes)), nil
		},
	}
}

// newRunServicesTool creates the run_services tool
func newRunServicesTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"run_services",
mcp.WithDescription("Start development services defined in azure.yaml, Aspire, or docker compose. This command will start the application in the background and return information about the started services."),
mcp.WithReadOnlyHintAnnotation(false),
mcp.WithIdempotentHintAnnotation(false),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
mcp.WithString("runtime",
mcp.Description("Optional runtime mode: 'azd' (default), 'aspire', 'pnpm', or 'docker-compose'."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

var cmdArgs []string

if projectDir, ok := args["projectDir"].(string); ok && projectDir != "" {
cmdArgs = append(cmdArgs, "--project", projectDir)
}

if runtime, ok := args["runtime"].(string); ok && runtime != "" {
cmdArgs = append(cmdArgs, "--runtime", runtime)
}

// Note: azd app run is interactive and long-running, so we run it in a non-blocking way
// and return information about the command being executed
cmd := exec.Command("azd", append([]string{"app", "run"}, cmdArgs...)...)

// Start the command but don't wait for it
if err := cmd.Start(); err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to start services: %v", err)), nil
}

result := map[string]interface{}{
"status":  "started",
"message": "Services are starting in the background. Use get_services to check their status.",
"pid":     cmd.Process.Pid,
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newInstallDependenciesTool creates the install_dependencies tool
func newInstallDependenciesTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"install_dependencies",
mcp.WithDescription("Install dependencies for all detected projects (Node.js, Python, .NET). Automatically detects package managers (npm/pnpm/yarn, uv/poetry/pip, dotnet) and installs dependencies."),
mcp.WithReadOnlyHintAnnotation(false),
mcp.WithIdempotentHintAnnotation(true),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

var cmdArgs []string

if projectDir, ok := args["projectDir"].(string); ok && projectDir != "" {
cmdArgs = append(cmdArgs, "--project", projectDir)
}

// Execute deps command
cmd := exec.Command("azd", append([]string{"app", "deps"}, cmdArgs...)...)
output, err := cmd.CombinedOutput()
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to install dependencies: %v\nOutput: %s", err, string(output))), nil
}

result := map[string]interface{}{
"status":  "completed",
"message": "Dependencies installed successfully",
"output":  string(output),
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newCheckRequirementsTool creates the check_requirements tool
func newCheckRequirementsTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"check_requirements",
mcp.WithDescription("Check if all required prerequisites (tools, CLIs, SDKs) defined in azure.yaml are installed and meet minimum version requirements. Returns detailed status of each requirement."),
mcp.WithReadOnlyHintAnnotation(true),
mcp.WithIdempotentHintAnnotation(true),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

var cmdArgs []string

if projectDir, ok := args["projectDir"].(string); ok && projectDir != "" {
cmdArgs = append(cmdArgs, "--project", projectDir)
}

result, err := executeAzdAppCommand("reqs", cmdArgs)
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to check requirements: %v", err)), nil
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newStopServicesTool creates the stop_services tool
func newStopServicesTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"stop_services",
mcp.WithDescription("Stop all running development services. This will gracefully shut down services started with run_services."),
mcp.WithReadOnlyHintAnnotation(false),
mcp.WithIdempotentHintAnnotation(true),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
// Note: azd app doesn't have a direct stop command, so we provide guidance
result := map[string]interface{}{
"status":  "info",
"message": "To stop services, use Ctrl+C in the terminal running 'azd app run', or use system tools to kill the process.",
"tip":     "You can use get_services to find the PID of running services.",
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newRestartServiceTool creates the restart_service tool
func newRestartServiceTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"restart_service",
mcp.WithDescription("Restart a specific service. This will stop and start the specified service."),
mcp.WithReadOnlyHintAnnotation(false),
mcp.WithIdempotentHintAnnotation(false),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("serviceName",
mcp.Description("Name of the service to restart"),
mcp.Required(),
),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

serviceName, ok := args["serviceName"].(string)
if !ok || serviceName == "" {
return mcp.NewToolResultError("serviceName parameter is required"), nil
}

result := map[string]interface{}{
"status":  "info",
"message": fmt.Sprintf("To restart service '%s', first stop it (Ctrl+C or kill PID), then use run_services to start it again.", serviceName),
"tip":     "Use get_services to find the current PID of the service.",
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newGetEnvironmentVariablesTool creates the get_environment_variables tool
func newGetEnvironmentVariablesTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"get_environment_variables",
mcp.WithDescription("Get environment variables configured for services. Returns all environment variables that services will use."),
mcp.WithReadOnlyHintAnnotation(true),
mcp.WithIdempotentHintAnnotation(true),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("serviceName",
mcp.Description("Optional service name to filter environment variables. If not provided, returns all."),
),
mcp.WithString("projectDir",
mcp.Description("Optional project directory path. If not provided, uses current directory."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

var cmdArgs []string

if projectDir, ok := args["projectDir"].(string); ok && projectDir != "" {
cmdArgs = append(cmdArgs, "--project", projectDir)
}

// Get service info which includes environment variables
result, err := executeAzdAppCommand("info", cmdArgs)
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to get environment variables: %v", err)), nil
}

// Extract environment variables from services
envVars := make(map[string]interface{})
if services, ok := result["services"].([]interface{}); ok {
serviceName, hasFilter := args["serviceName"].(string)

for _, svc := range services {
if svcMap, ok := svc.(map[string]interface{}); ok {
svcName, _ := svcMap["name"].(string)

// Skip if filtering and name doesn't match
if hasFilter && svcName != serviceName {
continue
}

if env, ok := svcMap["env"].(map[string]interface{}); ok {
envVars[svcName] = env
}
}
}
}

jsonBytes, err := json.MarshalIndent(envVars, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal environment variables: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newSetEnvironmentVariableTool creates the set_environment_variable tool
func newSetEnvironmentVariableTool() server.ServerTool {
return server.ServerTool{
Tool: mcp.NewTool(
"set_environment_variable",
mcp.WithDescription("Set an environment variable for services. Note: This provides guidance on how to set environment variables, as they must be configured in azure.yaml or .env files."),
mcp.WithReadOnlyHintAnnotation(true),
mcp.WithIdempotentHintAnnotation(true),
mcp.WithDestructiveHintAnnotation(false),
mcp.WithString("name",
mcp.Description("Name of the environment variable"),
mcp.Required(),
),
mcp.WithString("value",
mcp.Description("Value of the environment variable"),
mcp.Required(),
),
mcp.WithString("serviceName",
mcp.Description("Optional service name. If not provided, applies to all services."),
),
),
Handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
args, _ := request.Params.Arguments.(map[string]interface{})

name, ok1 := args["name"].(string)
value, ok2 := args["value"].(string)
if !ok1 || !ok2 || name == "" || value == "" {
return mcp.NewToolResultError("name and value parameters are required"), nil
}

serviceName := ""
if svc, ok := args["serviceName"].(string); ok {
serviceName = svc
}

guidance := fmt.Sprintf(`To set environment variable '%s=%s':

**Option 1: Update azure.yaml**
Add to the service configuration:
  services:
    %s:
      env:
        %s: "%s"

**Option 2: Use .env file**
Create/update .env file in project root:
  %s=%s

**Option 3: System environment**
Export in your shell:
  export %s="%s"

After updating, restart services for changes to take effect.`, 
name, value, 
serviceName, name, value,
name, value,
name, value)

result := map[string]interface{}{
"status":   "guidance",
"message":  guidance,
"variable": name,
"value":    value,
}

jsonBytes, err := json.MarshalIndent(result, "", "  ")
if err != nil {
return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal result: %v", err)), nil
}

return mcp.NewToolResultText(string(jsonBytes)), nil
},
}
}

// newAzureYamlResource creates a resource for reading azure.yaml
func newAzureYamlResource() server.ServerResource {
return server.ServerResource{
Resource: mcp.NewResource(
"azure://project/azure.yaml",
"azure.yaml",
mcp.WithResourceDescription("The azure.yaml configuration file that defines the project structure, services, and dependencies."),
),
Handler: func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
// Find and read azure.yaml
projectDir := "."
azureYamlPath := projectDir + "/azure.yaml"

content, err := os.ReadFile(azureYamlPath)
if err != nil {
return nil, fmt.Errorf("failed to read azure.yaml: %w", err)
}

return []mcp.ResourceContents{
&mcp.TextResourceContents{
URI:      request.Params.URI,
Text:     string(content),
MIMEType: "application/x-yaml",
},
}, nil
},
}
}

// newServiceConfigResource creates a resource for reading service configurations
func newServiceConfigResource() server.ServerResource {
return server.ServerResource{
Resource: mcp.NewResource(
"azure://project/services/configs",
"service-configs",
mcp.WithResourceDescription("Configuration details for all services including environment variables, ports, and runtime settings."),
),
Handler: func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
// Get service configurations
result, err := executeAzdAppCommand("info", []string{})
if err != nil {
return nil, fmt.Errorf("failed to get service configs: %w", err)
}

// Extract just the configuration parts (not runtime status)
configs := make(map[string]interface{})
if services, ok := result["services"].([]interface{}); ok {
for _, svc := range services {
if svcMap, ok := svc.(map[string]interface{}); ok {
svcName, _ := svcMap["name"].(string)
config := map[string]interface{}{
"name":      svcMap["name"],
"language":  svcMap["language"],
"framework": svcMap["framework"],
"project":   svcMap["project"],
"env":       svcMap["env"],
}
configs[svcName] = config
}
}
}

jsonBytes, err := json.MarshalIndent(configs, "", "  ")
if err != nil {
return nil, fmt.Errorf("failed to marshal configs: %w", err)
}

return []mcp.ResourceContents{
&mcp.TextResourceContents{
URI:      request.Params.URI,
Text:     string(jsonBytes),
MIMEType: "application/json",
},
}, nil
},
}
}
